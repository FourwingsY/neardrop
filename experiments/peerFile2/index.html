<meta charset="utf-8"/>
<link href='http://fonts.googleapis.com/css?family=Lato:100,400,100italic' rel='stylesheet' type='text/css'>
<title>다운받을때 FileSystem API 사용</title>
<style>
* {
	font-family: 'Lato', sans-serif;
}
html, body {
	margin: 0;
	padding: 0;
}
.message-list > span {
	display: block;	
	text-align: right;
	font-size: 30px;
}
.message-list > span.left {
	text-align: left;	
}
#my_pid
,#connection_status
{
	text-align: center;
	margin: 5px;
}
#connection_status {
	font-size: 14px;
	color: rgba(50,50,50,0.88);
}
#connection_status > b {
	font-size: 18px;
	color: rgba(89,86,86,0.88);
}
.input {
	position: fixed;
	bottom: 0;
	width: 100%;
}
input#pid {
	text-align: center;
}
.input > button
, .input > input
, input#pid
, button#connect
{
	width: 100%;
	padding: 10;
	background-color: rgba(100,100,100,.1);
	border: none;
	font-size: 20px;
}
.input > button
, button#connect {
	background-color: rgba(100,100,100,.1);
}
.input > input {
	width: 100%;
}

.progress-bar-container {
	width: 100%;
	height: 10px;
	background-color: rgba(100,100,100,.1);
}

.progress-bar-container > #send-chunk-progress-bar {
	width: 0%;
	height: 100%;
	background-color: rgba(100,250,100,.4);	
}
.progress-bar-container > #receive-chunk-progress-bar {
	width: 0%;
	height: 100%;
	background-color: rgba(100,100,250,.4);	
}
h2 {
	font-size: 16px;
}
</style>
<h1 id="my_pid"></h1>
<h2 id="connection_status"></h2>
<input id="pid"/>
<button id="connect">Connect</button>

<div id="fileInfo">
</div>

<h2>send chunk progress</h2>
<div class="progress-bar-container">
  <div id="send-chunk-progress-bar">
  </div>
</div>
<h2>receiving chunk progress</h2>
<div class="progress-bar-container">
  <div id="receive-chunk-progress-bar">
  </div>
</div>
<div class="speedInfo">
</div>
<div class="input">
<input id="file" type="file"/>
<button id="send">Send</button>
</div>
<script src="./FileSender.js"></script>
<script src="./FileSaver.js"></script>
<script src="./lib/peer.js"></script>
<script>

var CHUNK_SIZE = 130000; // MAGIC_NUMBER : 130000
var CHUNK_PACKAGE_SIZE = 1;

function Connection() {
	this.connection;
	
	// 전송시간, 전송속도 계산에 관련된 것 - 별로 안중요함
	this.transferStart;
	this.transferEnd;
	this.duration;
	
	this.fileSaver = new FileSaver();
	this.fileSender = new FileSender();
	
	this.peer = new Peer({key: '4uur7cd24jzwipb9'});
	this.initPeerEventHandler();
}

Connection.prototype.initPeerEventHandler = function() {
	// 내 연결 아이디를 발급 받았을 때
	this.peer.on('open', function(id){
		this.message({
			"status": "initConnection",
			"id": id,
		});
	}.bind(this));
	// 상대방과 연결을 수립했을 때
	this.peer.on('connection', function(dataConnection) {
		this.connection = dataConnection;
		this.initConnectionHandler();
	}.bind(this));
}

Connection.prototype._handleMessage = function(message) {
	var kind = message.kind; // chunk, meta, request
	switch (kind) {
		case "meta":
			console.log("[Connection : _handleMessage] incoming message META");
			var fileInfo = message.fileInfo;
			this.initSaver({
				name: fileInfo.name,
				size: fileInfo.size,
				type: fileInfo.type,
				lastModifiedDate: fileInfo.lastModifiedDate,
				chunkUnitSize: message.chunkUnitSize
			});
			break;
		case "chunk":
			this.fileSaver.saveChunk(message.chunk);
			var index = message.chunk.index;
			// 수신 시작 시각 저장 			
			if(index == 0) {
				this.transferStart = Date.now();
			}		
			break;
		case "request":
			var index = message.index;
			this.sendChunk(index);
		break;
		default:
			break;
	};
};

Connection.prototype.initConnectionHandler = function() {
	this.connection.on('open', function(){
		this.message({
			"status": "openConnection",
			"peerId": this.connection.peer,
		});
	}.bind(this));	
	this.connection.on('close', function(){
		this.message({
			"status": "closeConnection",
		});
	}.bind(this));		
	this.connection.on('data', function(message){
		//console.log(message);
		this._handleMessage(message);
	}.bind(this));
};

// 상대방과 연결을 맺기 
Connection.prototype.connect = function(peer_id){
	// Connection을 요청한다.
	this.connection = this.peer.connect(peer_id);
	// 커넥션이 맺어졌을때의 콜백 
	this.initConnectionHandler(this.connection);
};

// TODO : UI 관련 인데 돔 작업은 아님. 어쩔?!
Connection.prototype._getSizeExpression = function(size) { // byte
	var result = size;
	if(result < 1024) {
		return result + "Byte";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "KB";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "MB";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "GB";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "TB";
	}
};

// TODO : UI 관련은 다른데로 빼야함... 여기있으면 안댐.
Connection.prototype.showFileInfo = function(fileInfo) {
	var el = document.getElementById("fileInfo");
	el.innerHTML = "";
	el.innerHTML += "Filename: " + fileInfo.name + "<br/>";
	el.innerHTML += "Type: " + fileInfo.type + "<br/>";
	el.innerHTML += "Size: " + this._getSizeExpression(fileInfo.size) + "<br/>";
	el.innerHTML += "Last Modified Date: " + fileInfo.lastModifiedDate + "<br/>";
	el.innerHTML += "totalChunk: " +fileInfo.totalChunk + "<br/>";
};

// TODO : 여기도 UI 관련 작업들. 이렇게 해놓은 걸. 이벤트 에미터를 이용한 방식으로 바꿔야함...
Connection.prototype.message = function(param) {
    switch (param.status) {
		case 'receiveFinished':
			this.fileSaver.downloadFile();
				
			// 걸린 시간과 속도 화면에 표시
			var duration = (this.transferEnd - this.transferStart)/1000;
			var sizeExpression = this._getSizeExpression(this.fileSaver.meta.size);
			var speed = parseInt((parseFloat(sizeExpression)/ duration)*10)/10;
			var unit = sizeExpression.replace(/[^a-zA-Z]/g,'');
			document.querySelector(".speedInfo").innerHTML = "총 "+duration+"초 걸렸고 속도는 "+ speed+unit+"/s";

		break;
		case 'closeConnection':
			document.getElementById("connection_status").innerHTML = "disconnected";
		break;
		case 'openConnection':
			document.getElementById("connection_status").innerHTML = "connected to <b>"+param.peerId+"</b>";
		break;
		case 'initConnection':
			// 나의 ID를 화면에 보여줌
			document.querySelector('#my_pid').innerHTML = param.id;
		break;
		case 'log':
			console.log(param.message);  	
		break;
		case 'progress':
			//console.log("Send Chunk - 하는중"); 
			var progress = (param.current / param.total)*100;
			document.getElementById("send-chunk-progress-bar").setAttribute("style", "width:"+progress+"%");	
		break;
	}   	
};

Connection.prototype.initSaver = function(initParam) {	
	var initializeCallback = function(){	
		// 파일정보 수신 시 : UI 업데이트한다
		this.showFileInfo(this.fileSaver.meta);					
	}.bind(this);
	
	this.fileSaver.on("initialized", initializeCallback);		

	// 세이브 완료 시 : 다음 쳥크 요청하거나 수신 완료여부 체크 후
	var chunkSavedCallback = function(){
		// 다 받았는지 확인.
		if(this.fileSaver.receivedChunkCount == this.fileSaver.meta.totalChunk) {
			this.transferEnd = Date.now();
			//console.log("쳥크 다바다따!!: "+this.transferEnd);
			this.message({
				"status": "receiveFinished",
			});					
		}
		// 다 안받았으면 다음꺼 보내달라고 송신자에게 응답을 보낸다.
		else {
			if(this.connection && this.connection.open===true) {
				this.connection.send({
					  "kind": "request"
					, "index": this.fileSaver.getNextChunkIndexNeeded() // 필요한 쳥크 인덱스를 알려주는 메소드를 이용하면 될듯 
				});
			}
		} 
		// UI 업데이트한다 프로그레스 바를 업데이트 
		var progress = (this.fileSaver.receivedChunkCount / this.fileSaver.meta.totalChunk)*100;
		document.getElementById("receive-chunk-progress-bar").setAttribute("style", "width:"+progress+"%");
		
	}.bind(this);
				
	this.fileSaver.on("chunkSaved", chunkSavedCallback);	
	this.fileSaver.init({
		name: initParam.name,
		size: initParam.size,
		type: initParam.type,
		lastModifiedDate: initParam.lastModifiedDate,
		chunkUnitSize: initParam.chunkUnitSize
	});	
};
	
Connection.prototype.initSender = function(initParam) {	
	this.fileSender.on("initialized", function() {
		if(this.connection && this.connection.open===true) {
			console.log("메타 정보 보내기");
			this.connection.send({
				  "kind": "meta"
				, "fileInfo": {
					"lastModifiedDate": initParam.file.lastModifiedDate,
					"name": initParam.file.name,
					"size": initParam.file.size,
					"type": initParam.file.type	
				}
				, "chunkUnitSize": initParam.chunkUnitSize
			});
		}		
	}.bind(this));
	this.fileSender.init(initParam);
};

Connection.prototype.sendChunk = function(chunkIndex) {
	this.fileSender.getChunk(chunkIndex, function(chunk){
		if(this.connection && this.connection.open===true) {
			this.connection.send({
				  "kind": "chunk"
				, "chunk": chunk
			});
		}				
	}.bind(this));	
};

Connection.prototype.makeConnection = function(peerId) {
	this.connect(peerId,
	{
		reliable: false,
		serialization: "none"
	});
};


	
var APP = new Connection();

// 상대방 peer id가 적혀있을 때만 접속요청 시도할 수 있도록 함
document.getElementById("pid").addEventListener("change", function(e){
	var connectBtn = document.getElementById("connect");
	// 비어있다면 버튼 disable 시키고 안비어있으면 반대로 
	if(e.target.value.length > 0) {
		connectBtn.disabled = false;
	} else {
		connectBtn.disabled = true;
	}
});

// 연결 버튼을 누르면 연결을 시도함
document.getElementById("connect").addEventListener("click", function(){
	// 사용자가 입력한 상대방 아이디를 가져와서.
	var peer_id = document.querySelector('#pid').value;
	// 연결을 시도한다.
	APP.makeConnection(peer_id);
});

var fileControl = document.getElementById("file");

fileControl.addEventListener("change", function(event){
	var file = event.target.files[0];
	APP.initSender({
		"file": file,
		"chunkUnitSize": CHUNK_SIZE
	});
	// fileSender 초기과 콜백으로 UI 업뎃을 수행한다.
	APP.showFileInfo(APP.fileSender.meta);

}.bind(this));

// 전송 버튼을 누르면 메시지를 전달함
document.getElementById("send").addEventListener("click", function(){
	// 첫번째 쳥크를 보낸다.
	console.log("첫번째 쳥크를 구해온다");
	APP.sendChunk(0);
}.bind(this));


</script>
