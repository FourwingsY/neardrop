<meta charset="utf-8"/>
<link href='http://fonts.googleapis.com/css?family=Lato:100,400,100italic' rel='stylesheet' type='text/css'>
<title>다운받을때 FileSystem API 사용</title>
<style>
* {
	font-family: 'Lato', sans-serif;
}
html, body {
	margin: 0;
	padding: 0;
}
.message-list > span {
	display: block;	
	text-align: right;
	font-size: 30px;
}
.message-list > span.left {
	text-align: left;	
}
#my_pid
,#connection_status
{
	text-align: center;
	margin: 5px;
}
#connection_status {
	font-size: 14px;
	color: rgba(50,50,50,0.88);
}
#connection_status > b {
	font-size: 18px;
	color: rgba(89,86,86,0.88);
}
.input {
	position: fixed;
	bottom: 0;
	width: 100%;
}
input#pid {
	text-align: center;
}
.input > button
, .input > input
, input#pid
, button#connect
{
	width: 100%;
	padding: 10;
	background-color: rgba(100,100,100,.1);
	border: none;
	font-size: 20px;
}
.input > button
, button#connect {
	background-color: rgba(100,100,100,.1);
}
.input > input {
	width: 100%;
}

.progress-bar-container {
	width: 100%;
	height: 10px;
	background-color: rgba(100,100,100,.1);
}

.progress-bar-container > #send-chunk-progress-bar {
	width: 0%;
	height: 100%;
	background-color: rgba(100,250,100,.4);	
}
.progress-bar-container > #receive-chunk-progress-bar {
	width: 0%;
	height: 100%;
	background-color: rgba(100,100,250,.4);	
}
h2 {
	font-size: 16px;
}
</style>
<h1 id="my_pid"></h1>
<h2 id="connection_status"></h2>
<input id="pid"/>
<button id="connect">Connect</button>

<div id="fileInfo">
</div>

<h2>send chunk progress</h2>
<div class="progress-bar-container">
  <div id="send-chunk-progress-bar">
  </div>
</div>
<h2>receiving chunk progress</h2>
<div class="progress-bar-container">
  <div id="receive-chunk-progress-bar">
  </div>
</div>
<div class="speedInfo">
</div>
<div class="input">
<input id="file" type="file"/>
<button id="send">Send</button>
</div>
<script src="./FileSender.js"></script>
<script src="./FileSaver.js"></script>
<script src="./lib/peer.js"></script>
<script>

var CHUNK_SIZE = 16000; // 16000 byte per binary chunk
var BLOCK_SIZE = 64; // 10 binary chunks per one block

function Connection() {
	this.connection;
	
	// 전송시간, 전송속도 계산에 관련된 것 - 별로 안중요함
	this.transferStart;
	this.transferEnd;
	this.duration;
	
	
	this.fileSaver = new FileSaver();
	this.fileSender = new FileSender();
		
	this.peer = new Peer({
		key: '4uur7cd24jzwipb9'
		, debug: true	
	});
	
	this.initPeerEventHandler();
}

Connection.prototype.initPeerEventHandler = function() {
	// 내 연결 아이디를 발급 받았을 때
	this.peer.on('open', function(id){
		this.message({
			"status": "initConnection",
			"id": id,
		});
	}.bind(this));
	// 상대방과 연결을 수립했을 때
	this.peer.on('connection', function(dataConnection) {
		this.connection = dataConnection;
		this.initConnectionHandler();
	}.bind(this));
}

Connection.prototype._handleMessage = function(message) {
	if( message.byteLength !== undefined ) { // ArrayBuffer 가 도착한 것
		console.log("Received ByteLength : "+message.byteLength);	
		this.fileSaver.saveChunk(message);
	}
	else { // JSON이 도착한 것 
		var kind = message.kind; // chunk, meta, request
		switch (kind) {
			case "fileInfo": // 송신자가 보낸 파일 정보가 도착했다. 이를 가지고 file saver 를 초기화한다.
				console.log("[Connection : _handleMessage] incoming message file info");
				var fileInfo = message.fileInfo;
				this.initSaver({
					"file": fileInfo,
					"chunkSize": CHUNK_SIZE,
					"blockSize": BLOCK_SIZE
				});
				break;
			case "requestBlock":  // 수신자가 보낸 요청 블록 정보가 도착했다. 이를 통해 현재 블록전송 콘텍스트를 초기화 한다.
				console.log("[Connection : _handleMessage] incoming message requestBlock");
				console.log("blockIndex : " + message.blockIndex);

				var blockIndex = message.blockIndex;
				this.fileSender.initBlockContext(blockIndex);				
			break;
			case "requestChunk": // 수신자가 다 받았음을 알리면 다음 쳥크를 보낸다.
				console.log("[Connection : _handleMessage] incoming message requestChunk");
				this.sendDataChunk();
			break;
			default:
				break;
		};
	}
};

Connection.prototype.sendDataChunk = function() {
	var getNextChunkHandler = function(chunk){
		console.log(chunk);
		if(chunk) {
			if(this.connection && this.connection.open===true) {
				this.connection.send(chunk);
			}
		}
	}.bind(this);

	this.fileSender.getNextChunk(getNextChunkHandler);
}

Connection.prototype.initConnectionHandler = function() {
	this.connection.on('open', function(){
		this.message({
			"status": "openConnection",
			"peerId": this.connection.peer,
		});
	}.bind(this));	
	this.connection.on('close', function(){
		this.message({
			"status": "closeConnection",
		});
	}.bind(this));		
	this.connection.on('data', function(message){
		this._handleMessage(message);
	}.bind(this));
};

// 상대방과 연결을 맺기 
Connection.prototype.connect = function(peer_id){
	// Connection을 요청한다.
	this.connection = this.peer.connect(peer_id);
	// 커넥션이 맺어졌을때의 콜백 
	this.initConnectionHandler(this.connection);
};

// TODO : UI 관련 인데 돔 작업은 아님. 어쩔?!
Connection.prototype._getSizeExpression = function(size) { // byte
	var result = size;
	if(result < 1024) {
		return result + "Byte";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "KB";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "MB";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "GB";
	}
	result = Math.floor(result / 1024.0 * 10)/10;
	if(result < 1024) {
		return result + "TB";
	}
};

// TODO : UI 관련은 다른데로 빼야함... 여기있으면 안댐.
Connection.prototype.showFileInfo = function(fileInfo) {
	var el = document.getElementById("fileInfo");
	el.innerHTML = "";
	el.innerHTML += "Filename: " + fileInfo.name + "<br/>";
	el.innerHTML += "Type: " + fileInfo.type + "<br/>";
	el.innerHTML += "Size: " + this._getSizeExpression(fileInfo.size) + "<br/>";
	el.innerHTML += "Last Modified Date: " + fileInfo.lastModifiedDate + "<br/>";
	el.innerHTML += "totalChunk: " +fileInfo.totalChunk + "<br/>";
};

// TODO : 여기도 UI 관련 작업들. 이렇게 해놓은 걸. 이벤트 에미터를 이용한 방식으로 바꿔야함...
Connection.prototype.message = function(param) {
    switch (param.status) {
		case 'receiveFinished':
			this.fileSaver.downloadFile();
				
			// 걸린 시간과 속도 화면에 표시
			var duration = (this.transferEnd - this.transferStart)/1000;
			var sizeExpression = this._getSizeExpression(this.fileSaver.fileInfo.size);
			var speed = parseInt((parseFloat(sizeExpression)/ duration)*10)/10;
			var unit = sizeExpression.replace(/[^a-zA-Z]/g,'');
			document.querySelector(".speedInfo").innerHTML = "총 "+duration+"초 걸렸고 속도는 "+ speed+unit+"/s";

		break;
		case 'closeConnection':
			document.getElementById("connection_status").innerHTML = "disconnected";
		break;
		case 'openConnection':
			document.getElementById("connection_status").innerHTML = "connected to <b>"+param.peerId+"</b>";
		break;
		case 'initConnection':
			// 나의 ID를 화면에 보여줌
			document.querySelector('#my_pid').innerHTML = param.id;
		break;
		case 'log':
			console.log(param.message);  	
		break;
		case 'progress':
			//console.log("Send Chunk - 하는중"); 
			var progress = (param.current / param.total)*100;
			document.getElementById("send-chunk-progress-bar").setAttribute("style", "width:"+progress+"%");	
		break;
	}   	
};

Connection.prototype.initSaver = function(initParam) {	
	var initializeCallback = function(){	
		// 파일정보 수신 시 : UI 업데이트한다
		this.showFileInfo(this.fileSaver.fileInfo);					
	}.bind(this);
	
	this.fileSaver.on("initialized", initializeCallback);		

	// 세이브 완료 시 : 다음 쳥크 요청하거나 수신 완료여부 체크 후
	var blockSavedCallback = function(){
		// 다 받았는지 확인.
		if(this.fileSaver.blockTranferContext.receivedBlockCount == this.fileSaver.blockTranferContext.totalBlockCount) {
			this.transferEnd = Date.now();
			console.log("쳥크 다바다따!!: "+this.transferEnd);
			this.message({
				"status": "receiveFinished",
			});					
		}
		// 다 안받았으면 다음 블록을 보내달라고 송신자에게 응답을 보낸다.
		else {
			this.requestBlockTransfer();
		} 
		// UI 업데이트한다 프로그레스 바를 업데이트 
		var progress = (this.fileSaver.blockTranferContext.receivedBlockCount / this.fileSaver.blockTranferContext.totalBlockCount)*100;
		document.getElementById("receive-chunk-progress-bar").setAttribute("style", "width:"+progress+"%");
	}.bind(this);
				
	this.fileSaver.on("blockSaved", blockSavedCallback);	
	
	var chunkStoredCallback = function(){
		this.connection.send({
			  "kind": "requestChunk"
		});		
	}.bind(this);
	
	this.fileSaver.on("chunkStored", chunkStoredCallback);		

	this.fileSaver.init({
		file: initParam.file,
		chunkSize: initParam.chunkSize,
		blockSize: initParam.blockSize
	});	
};
	
Connection.prototype.initSender = function(initParam) {	

	var blockContextInitializedCallback = function(e) {
		this.sendDataChunk();
	}.bind(this);
	this.fileSender.on("blockContextInitialized", blockContextInitializedCallback);	
				
	this.fileSender.on("initialized", function() {
		if(this.connection && this.connection.open===true) {
			console.log("메타 정보 보내기");
			this.connection.send({
				  "kind": "fileInfo"
				, "fileInfo": {
					"lastModifiedDate": initParam.file.lastModifiedDate,
					"name": initParam.file.name,
					"size": initParam.file.size,
					"type": initParam.file.type	
				}
				, "chunkSize": initParam.chunkSize
				, "blockSize": initParam.blockSize
			});
		}		
	}.bind(this));
	this.fileSender.init(initParam);
};

Connection.prototype.makeConnection = function(peerId) {
	this.connect(peerId,
	{
		reliable: false,
		serialization: "none"
	});
};

Connection.prototype.requestBlockTransfer = function() {
	if(this.connection && this.connection.open===true) {	
		this.fileSaver.blockTranferContext.blockIndex = this.fileSaver.getNextBlockIndexNeeded();
		this.connection.send({
			  "kind": "requestBlock",
			  "blockIndex": this.fileSaver.blockTranferContext.blockIndex
		});
	}
};
	
var APP = new Connection();

// 상대방 peer id가 적혀있을 때만 접속요청 시도할 수 있도록 함
document.getElementById("pid").addEventListener("change", function(e){
	var connectBtn = document.getElementById("connect");
	// 비어있다면 버튼 disable 시키고 안비어있으면 반대로 
	if(e.target.value.length > 0) {
		connectBtn.disabled = false;
	} else {
		connectBtn.disabled = true;
	}
});

// 연결 버튼을 누르면 연결을 시도함
document.getElementById("connect").addEventListener("click", function(){
	// 사용자가 입력한 상대방 아이디를 가져와서.
	var peer_id = document.querySelector('#pid').value;
	// 연결을 시도한다.
	APP.makeConnection(peer_id);
});

var fileControl = document.getElementById("file");

fileControl.addEventListener("change", function(event){
	var file = event.target.files[0];
	APP.initSender({
		"file": file,
		"chunkSize": CHUNK_SIZE,
		"blockSize": BLOCK_SIZE
	});
	// fileSender 초기과 콜백으로 UI 업뎃을 수행한다.
	APP.showFileInfo(APP.fileSender.fileInfo);

}.bind(this));

// 전송 버튼을 누르면 메시지를 전달한당
document.getElementById("send").addEventListener("click", function(){
	console.log("첫번째 쳥크를 구해온다");
	APP.transferStart = Date.now();
	APP.requestBlockTransfer();
}.bind(this));


</script>
